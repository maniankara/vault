# packages.yml
#
# packages.yml defines all the packages we are able to build for a single commit
# in this repo. A package means a single zip file containing the executable binary,
# and optionally other files if needed.
#
# packages.yml is a convenience file for the human management of large numbers of
# alternate packages, allowing default and templated values. We generate another
# file from this one, called packages.lock which contains the fully expanded set
# of package specs. This fully expanded file is in turn used to generate CI config
# to build specific sets of packages.
#
# Each package defined by this file is a set of environment variables that are
# passed into the build command 'make package'. See GNUMakefile in this directory.
#
# defaults contains default values for each package.
# These values may be overridden on a per-package basis in the packages section.
defaults:
  # PRODUCT_NAME is the name of the product we are building. It should also
  # be used in the PACKAGE_NAME template.
  PRODUCT_NAME: vault

  # BINARY_NAME is the name of the executable binary we compile and package.
  # It is the name users will use on the CLI to invoke the product.
  BINARY_NAME: vault

  # PRODUCT_EDITION is an additional differentiator for a given package. It should
  # be used in the PACKAGE_NAME template.
  PRODUCT_EDITION: ""

  # PRODUCT_VERSION is the version of this product. Usually, this should be left
  # as 0.0.0-snapshot. When we build a release candidate, this is overridden in
  # a one-off fashion to produce that build.
  # This should be used in the PACKAGE_NAME template.
  PRODUCT_VERSION: 0.0.0-snapshot

  # PUBLIC dictates if this package may eventually be uploaded to
  # releases.hashicorp.com where it will be accessible to the world.
  PUBLIC: YES

  # GO_VERSION is the version of the Go toolchain to use to compile this package.
  GO_VERSION: 1.12.13

  # YARN_VERSION is the version of Yarn to install for the UI layer.
  YARN_VERSION: 1.19.1-1

  # BUILD_TAGS are passed as-is to the -tag flag of 'go build'. It should be
  # a comma or space separated list, depending on the GO_VERSION you are using.
  BUILD_TAGS: vault

  # Standard golang environment variables, passed to the 'go build' command.
  # You can use any standard environment variables here, any that you omit
  # will be ommitted from the go build command too, meaning to use the system
  # default in the build container.
  CGOENABLED: 0
  GO111MODULE: "off"

# meta contains additional metadata to pass into the build. This metadata does not
# participate in the PACKAGE_SPEC_ID and so changing it does not directly change cache
# keys for layers or packages. In addition, metadata may not be overridden per-package
# and is not available to templates.
#
# We need this meta layer spearate from the build inputs in order to pre-calculate
# useful fields for CI workflow template rendering etc, without invalidating all the
# layer caches needlessly.
#
# Additional keys are automatically added to meta when running `make packages` these
# are things like the calcualted PACKAGE_SPEC_ID and calculated cache keys etc.
meta:
  # PRODUCT_REVISION is the revision of the source code to build.
  # This is a git ref i.e. a commit SHA, branch name or tag.
  # If left empty ("") then default to building whatever is in the current
  # working tree, even if it is dirty (contains uncommitted changes).
  # This should usually be left empty, it is overridden on a one-off basis
  # when producing release or custom builds.
  #
  # PRODUCT_REVISION is a meta field, because multiple different revisions here may
  # point to the same underlying Git commits and/or git trees, making them equivalent,
  # enabling us avoid invalidating layer cachces unnecessarily.
  PRODUCT_REVISION: ""

# templates contain golang template strings. Each of these is rendered per package
# using that packages values (including any default values), and then added to that
# package.
# Note that templates MAY NOT refer to each other.
templates:
  # PRODUCT_VERSION_MMP is just the major.minor.prerelease fields of the PRODUCT_VERSION.
  # Think semantic versioning (semver), although we do not version our binaries
  # using semver.
  PRODUCT_VERSION_MMP: >-
    {{with .PRODUCT_VERSION | strings.SplitN "-" 2}}{{index . 0}}{{end}}
  # PRODUCT_VERSION_PRE is just the prerelease field of the product version (i.e. the bit
  # after any -, if there is one.
  PRODUCT_VERSION_PRE: >-
    {{with .PRODUCT_VERSION | strings.SplitN "-" 2}}{{if gt (len .) 1}}{{index . 1}}{{else}}"''"{{end}}{{end}}
  # BUNDLE_NAME is the name of the release bundle this package belongs to.
  # All packages with the same BUNDLE_NAME are considered part of the same release
  # bundle, and are placed in the same directory on releases.hashicorp.com, as well
  # as sharing a SHASUMS file.
  BUNDLE_NAME: >-
    {{.PRODUCT_NAME}}_{{.PRODUCT_VERSION}}{{if .PRODUCT_EDITION}}+{{.PRODUCT_EDITION}}{{end}}
  # PACKAGE_NAME is the name of a specific package. Care must be taken to ensure this
  # is unique per package. The final zip file we produce per package uses this name.
  PACKAGE_NAME: >-
    {{.PRODUCT_NAME}}_{{.PRODUCT_VERSION}}{{if .PRODUCT_EDITION}}+{{.PRODUCT_EDITION}}{{end}}_{{.GOOS}}_{{.GOARCH}}
  # BUILD_JOB_NAME is the name of a job to build this package in CI. Care must be
  # taken that it is both unique within this set of packages, as well as compatible
  # with the CI system's naming conventions.
  BUILD_JOB_NAME: >-
    package_{{if .PRODUCT_EDITION}}{{.PRODUCT_EDITION}}_{{end}}{{.GOOS}}_{{.GOARCH}}

  # PACKAGE_OUT_ROOT is the root directory we output the package to.
  # It must be a relative path (relative to the root of the repo).
  # We extend this with the calculated PACKAGE_SPEC_ID and PACKAGE_SOURCE_ID during
  # the build.
  PACKAGE_OUT_ROOT: >-
    {{ "dist" -}}
    /{{- if .PUBLIC}}public{{else}}private{{end -}}
    /{{- .PRODUCT_NAME}}_{{.PRODUCT_VERSION}}{{if .PRODUCT_EDITION}}+{{.PRODUCT_EDITION}}{{end -}}

# build-command-template is a template for the command we run in the container to produce a package.
# This template recieves a full package definition from packages.lock/pkgs.yml, so can refer to any
# of the inputs or metadata. In addition, it recieves a top-level key "build" containing the following
# fields:
#
#   .build.ENV               : All the inputs for this build in the form NAME='VALUE', separated with spaces.
#   .build.PACKAGE_SOURCE_ID : The Git commit SHA (if clean) or "dirty_<unique SHA>" if dirty.
#   .build.PACKAGE_DIR       : Absolute directory to output the final package to.
#   .build.PACKAGE_FILENAME  : The filename of the package to output to PACKAGE_DIR.
#
# It's important to note that the build-command is not evaluated at package lock time, but only
# at build time. Therefore, referencing metadata in the build command does not affect the address
# (cache-key) of the binary. The build command template itself (before being rendered) is considered
# an input, so changing it will invalidate package caches.
build-command-template: >
  {{.build.ENV}} go build -v -tags '{{.inputs.BUILD_TAGS}}' -ldflags "
    -X github.com/hashicorp/vault/vendor/github.com/hashicorp/vault/sdk/version.GitCommit={{.build.PACKAGE_SOURCE_ID}}
    -X github.com/hashicorp/vault/vendor/github.com/hashicorp/vault/sdk/version.Version={{.inputs.PRODUCT_VERSION_MMP}}
    -X github.com/hashicorp/vault/vendor/github.com/hashicorp/vault/sdk/version.Prerelease={{.inputs.PRODUCT_VERSION_PRE}}
  " -o {{.build.PACKAGE_DIR}}/{{inputs.BINARY_NAME}}
  && cd {{.build.PACKAGE_DIR}} && zip {{.build.PACKAGE_FILENAME}} {{.inputs.BINARY_NAME}}



# packages is the full set of packages we are able to build based on a single commit
# in this repo. Each package is a map where the keys are the names of environment
# variables provided to each build (think 'go build' invocation). Each package is
# expanded by first filling in any unspecified variables with those from defaults,
# and then rendering each template and adding the result to the map.
# Each package must result in a unique PACKAGE_NAME.
#
# The fully expanded set of packages are written to packages.lock. That file
# is a useful data source for building CI/CD pipelines.
packages:
  - { GOOS: darwin, GOARCH: 386 }
  - { GOOS: darwin, GOARCH: amd64 }
  - { GOOS: freebsd, GOARCH: 386 }
  - { GOOS: freebsd, GOARCH: amd64 }
  - { GOOS: freebsd, GOARCH: arm }
  - { GOOS: linux, GOARCH: 386 }
  - { GOOS: linux, GOARCH: amd64 }
  - { GOOS: linux, GOARCH: arm }
  - { GOOS: linux, GOARCH: arm64 }
  - { GOOS: netbsd, GOARCH: 386 }
  - { GOOS: netbsd, GOARCH: amd64 }
  - { GOOS: openbsd, GOARCH: 386 }
  - { GOOS: openbsd, GOARCH: amd64 }
  - { GOOS: solaris, GOARCH: amd64 }
  - { GOOS: windows, GOARCH: 386 }
  - { GOOS: windows, GOARCH: amd64 }

# Layers determines the build layers, which are individually cacheable layers
# in a linear build. Each layer contains a Dockerfile. All the layers
# together produce the final builder image used to compile binaries.
#
# The partial Dockerfiles may contain references to any of the variables
# including rendered template variables. The checksum of the cumulative
# layers up to each layer is calculated using the source included as well
# as the rendered Dockerfile. Thus you can control cacheability by careful
# use of variables. It is recommended not to use any variables that vary per-
# package in these Dockerfiles, as that enables a single docker image to be
# produced per set of packages.
#
# The order of layers is significant. The first layer must have a FROM line, and
# forms the base image. Each subsequent layer begins from the previous one.
layers:
  - name: base
    source-include: ""
    source-exclude: ""
    dockerfile: |-
      FROM debian:buster
      RUN apt-get update -y && apt-get install --no-install-recommends -y -q \
                               curl \
                               zip \
                               build-essential \
                               gcc-multilib \
                               g++-multilib \
                               ca-certificates \
                               git mercurial bzr \
                               gnupg \
                               libltdl-dev \
                               libltdl7 \
      						             bash
      RUN curl -sL https://deb.nodesource.com/setup_10.x | bash -
      RUN curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -
      RUN echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list
      RUN apt-get update -y && apt-get install -y -q nodejs yarn={{.YARN_VERSION}}
      RUN rm -rf /var/lib/apt/lists/*

      ENV GOPATH /gopath
      ENV GOROOT /goroot

      RUN mkdir $GOROOT && mkdir $GOPATH

      RUN curl https://storage.googleapis.com/golang/go{{.GO_VERSION}}.linux-amd64.tar.gz \
                 | tar xvzf - -C $GOROOT --strip-components=1

      ENV PATH $GOROOT/bin:$GOPATH/bin:$PATH

      RUN go get golang.org/x/tools/cmd/goimports
      RUN go get github.com/mitchellh/gox
      RUN go get github.com/hashicorp/go-bindata
      RUN go get github.com/hashicorp/go-bindata/go-bindata
      RUN go get github.com/elazarl/go-bindata-assetfs
      RUN go get github.com/elazarl/go-bindata-assetfs/go-bindata-assetfs

      ENV REPO=github.com/hashicorp/vault
      ENV DIR=$GOPATH/src/$REPO

      RUN mkdir -p $DIR

      WORKDIR $DIR

  # Because each layer is a small, separate Dockerfile, rather than a cumulative
  # Dockerfile, we add a comment to each one, containing the checksum of the
  # underlying one. This ensures that any changes to underlying Dockerfiles will
  # result in new subsequent Dockerfilees. This is important because when
  # calculating the source ID, we must also take into consideration the source
  # of the Docker container we are building in. By having the checksums flow
  # through the source, we are able to just take just the last layer's
  # Dockerfile into consideration, rather than all of them.
  # The comments look like this:
  #
  # Note that the source ID of the _images_ built using these Dockerfiles
  # is additionally dictated by the source included in that layer.
  - name: yarn
    source-include: ui/package.json ui/yarn.lock
    source-exclude: ""
    dockerfile: |-
      ARG BASE_IMAGE
      FROM $BASE_IMAGE
      COPY . ./
      RUN cd ui && yarn install
      RUN cd ui && npm rebuild node-sass
  - name: ui
    source-include: ui/
    source-exclude: ""
    dockerfile: |-
      ARG BASE_IMAGE
      FROM $BASE_IMAGE
      COPY . ./
      RUN cd ui && yarn run build
  - name: static
    source-include: .
    source-exclude: .circleci/ release/
    dockerfile: |-
      ARG BASE_IMAGE
      FROM $BASE_IMAGE
      COPY . ./
      RUN make static-assets
